---
layout:     post
title:      非实时优先权线程调度器-源码分析
subtitle:   嵌入式开发 内核进阶
date:       2020-01-21
author:     Shawn.Tan
header-img: img/post-bg-scheduler3-web.jpg
catalog: true
tags:
    - 嵌入式
    - SSD
    - CPU架构
    - 操作系统
    - RISC-V
---
# 前言

**调度器**(**scheduler**)是计算机操作系统内核中对进程/线程分配CPU计算资源的重要模块

![调度器功能](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-sheduler-structure-web1.jpg)

在桌面机，嵌入式设备或大型机等不同的应用环境中，产生了不同类型资源分配策略的调度器，针对不同层面分为以下几种调度器

- **高级调度器（long-term scheduler）：** 通常用于面向批处理的多程序环境中，通过均衡内存中的任务以优化系统资源，包括CPU，内存和硬盘存储等。

- **中级调度器（medium-term scheduler）：** 跟踪CPU上执行的进程/线程的动态内存用量来决定是否要增加或减少“多通道程度“（内存中竞争CPU的进程个数），以防止”颠簸“。颠簸即当前的进程集合的内存需求超过了系统容量，导致进程在各自的执行中变得缓慢。

- **低级调度器（short-term scheduler）：** 负责在当前驻留的内存里的进程/线程中选择一个来运行。这篇内容设计的算法主要关注的都是低级调度器

**在之前的项目工作中研究了一种部署在Xilinx MicroBlaze 嵌入式平台中的低级调度器**，计划按以下四个部分介绍该调度器的具体实现和改进实验

1. 调度器源码分析
2. 基于VEGA织女星NXP-RVM1-Series RI5CY平台的调度器移植实验
3. 基于中断时间片的调度器改进实验
4. 调度器性能分析

**本篇文章为第一部分将分析该调度器的源码实现。** 在低级调度器中，一般划分为：**非抢占式**和**抢占式**。非抢占式的调度器中，一个进程/线程或采用执行到底策略，或主动释放资源放弃占用处理器时间以处理I/O请求，调度器只负责安排进程/线程执行顺序；而抢占式调度器则从主动从当前线程手中把处理器计算资源抢走，并交给另一个进程/线程使用。不管是哪一类调度器都会按照以下四项开展调度工作：

- 获得处理器的控制权
- 保存当前正在运行的进程/线程状态（PCB，process control block）
- 选择一个新的进程/线程来执行
- 提交新选择出来的进程/线程给处理器运行，将该进程/线程的PCB状态加载到CPU寄存器中
   
进程/线程状态包含了程序执行中的关键信息，例如当前程序执行位置（PC指针），过程调用（sub-routine）返回地址，程序在存储空间的现场（**context**，程序上下文）等等，是调度器执行调度任务的重要信息部分。

# 源码分析

## 基本结构

调度器由以下6个基本类组成

类名|功能说明
:--:|--
thread_dt|装载任务线程thread的运行状态（PCB）
threadext_dt|指定任务线程thread的栈（stack）空间，管理线程函数的函数指针及参数
contexqueue|管理PCB线程池的单向链表队列
thread_lib|调度器的核心类，包含调度器线程管理的所有方法和线程资源池
event_dt|线程事件的实现类，包含事件的实现方法及操作函数
semaphore_dt|信号量旗语的实现类，包含信号量的实现及操作方法

`class thread_lib`是整个调度器的核心类，下图为整个调度器的组织结构

![调度器结构关系](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-threadlib-web.jpg)

## 代码分析

- ### **thread_dt类**

`class thread_dt`是上文所提到的PCB内容的容器，实现如下：

```cpp
class thread_dt
{
public:
#ifdef WIN32
	LPVOID thread_fiber;
#else
	uint32 sp;             //栈指针
	union
	{
		uint32 reg[15];    //部分CPU通用寄存器保存
		struct
		{
			uint32 r15;    //sub-routine结束后的返回地址, 在microblaze体系中，r15用于保存返回地址
			uint32 r17;
			uint32 r19;
			uint32 r20;
			uint32 r21;
			uint32 r22;
			uint32 r23;
			uint32 r24;
			uint32 r25;
			uint32 r26;
			uint32 r27;
			uint32 r28;
			uint32 r29;
			uint32 r30;
			uint32 r31;
		};
	};
#endif
	threadext_dt *extdat;    //线程任务的操作类指针
	thread_dt *next;         //线程池链表的尾指针
   	uint32 priority;         //任务的优先级
#ifdef PROBE_LOG
	uint32 count;
	char funcname[12];
#endif
};
```

`class thread_dt`保存了线程运行的所有关键现场信息，包括以下5部分

1. 部分CPU通用寄存器（GPR， General Purpose Register）的当前状态  
2. 程序计数器的当前指令执行地址，用与产生sub-routine结束后的返回地址
3. 栈（Stack）指针 
4. 线程任务的操作内容对象指针
5. 线程任务优先级 

通过上述五部分所描述的线程上下文现场信息，处理器可以切换到指定sub-routine执行新的任务。通常寄存器文件信息只需保存两类寄存器作为关键现场信息：由**Saving Registers**与**Temporry Registers**

![microbalze寄存器功能描述](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-mb_registers_web.jpg)

按上图给出的定义所以对线程执行现场的保存需要保存**r15，r17，r19-r31**等15个必要GPR寄存器 


- ### **threadext_dt类**

`class threadext_dt`是线程任务函数的容器，其实现代码如下：

```cpp
class threadext_dt
{
public:
	static const uint32 thread_stack_size = 520284; //Near 512k. Not exactly 512k to avoid cache collision.  栈空间大小
#ifndef WIN32
	uint8 astack[thread_stack_size];  //栈空间
#endif
	thread_fn thread_start;           //线程任务函数指针
	void *thread_arg;                 //线程任务函数参数
};
```

`class threadext_dt` 保存的内容主要有三点：

1. 线程的栈空间内容
2. 任务线程函数指针，该指针在具体的线程任务创建时需要和实际的执行函数地址绑定，所支持的线程函数格式要求如下：
   **`void (*thread_fn)(void *arg)`**
3. 任务线程函数的参数列表指针

线程空间所制定的栈空间大小比cache的物理尺寸(512KB)少一个内存页框（page frame， 4KB）的大小。这种设计的目的在于当cache基于4KB大小的cacheline做刷新时，cache通过DataBus总线访问主存的最大单次数据传输宽度为256bit*16等于4KB。当cache miss时，cache可直接使用这个多余的空cacheline从主存调入新块，并更新cam表映射，上述情况可在Data Cache Miss的数据量小于一个物理页范围时减少一次Cache Line的Write Back操作，从而减少Cache Miss带来的访存延迟惩罚（penalty）。由于上述线程的保存并没有利用线程任务的PID，因此在线程任务在切换时，前面线程存放于cache的数据对当前线程均miss，因此在存储切换时可能有较大由于cache warm up所带来的访存颠簸。

- ## **contextqueue类**

`class contexqueue`实现了对线程池的管理功能， 实现如下：

```cpp
class contextqueue
{
private:
	thread_dt* volatile head;
	thread_dt* volatile * volatile tail;

public:
	inline void init()
	{
		head = NULL;
		tail = &head;
	}

	inline thread_dt* volatile current()
	{
		return head;
	}

	inline void insert(thread_dt* c)
	{
		c->next = NULL;
		*tail = c;
		tail = &c->next;
	}

	inline void inserthead(thread_dt* c)
	{
		c->next = head;
		if(head == NULL)
		{
			tail = &c->next;
		}
		head = c;
	}

	inline void batchinsert(contextqueue &addqueue)
	{
		ASSERT(addqueue.head != NULL,LEVEL_NORMAL);
		*tail = addqueue.head;
		tail = addqueue.tail;
	}

	inline void remove()
	{
		if ((head = head->next) == NULL)
		{
			tail = &head;
		}
	}

	inline void removeall()
	{
		init();
	}

	inline void rotate()
	{
		ASSERT(head != NULL,LEVEL_NORMAL);
		*tail = head;
		tail = &head->next;
		head = head->next;
		*tail = NULL;
	}
};
```
上述线程池为单向链表结构，并提供了8种资源管理方法

函数名|功能简介
:--:|--
init()|线程池的初始化方法
current()|返回线程池链表的头部元素指针
insert()|在线程池链表尾部插入新的线程元素
inserthead()|在线程池链表的头部插入新的线程元素
batchinsert()|在线程池链表的尾部插入新的线程池链表
remove()|删除线程池链表的头部元素
removeall()|删除整个线程池链表（重新初始化线程池）
retate()|线程池的初始化方法
init()|线程池的初始化方法

### 线程池init方法

![init](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-cq-init-web.jpg)

线程池的初始化方法通过首尾指针构造了一个以`class thread_dt`对象为元素的空白单向链表结构，头部指针指向一个NULL对象，尾部的二级指针指向头部指针地址的位置。

### 线程池insert方法

![insert](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-cq-insert-web.jpg)

线程池对象的插入方法将原线程池尾部元素的后驱指针连接到新元素，移动尾部指针的指向新元素的后驱指针位置，尾部元素的后驱指针需要指向NULL

### 线程池inserthead方法

![inserthead](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-inserthead-web.jpg)

线程池的头部插入方法将新元素的后驱指针指向原链表的头部，特别在空表插入情况下，需要将尾部指针定位到新元素的后驱指针地址位置，最后更新头部指针指向新元素即可

### 线程池batchinsert方法

![batchinsert](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-batchinsert-web.jpg)

对线程池尾部插入一个线程链表需将尾指针指向新链表的头部元素，同时移动尾指针执行新链表的尾部元素的后驱指针

### 线程池remove方法

![remove](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-remove-web.jpg)

线程池链表元素的删除总是删除头部元素，当删除后为非空链表，只需将头部指针移向原头部的后续元素，当出现删空时，则还需要将尾部指针也指向原头部后驱指针的地址位置

### 线程池removeall方法

等同于重新初始化线程池

### 线程池rotate方法

![rotate](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-rotate-web.jpg)

线程池的元素旋转方法是调度器的调度策略的重要操作，目的使原链表的头部元素被替换到尾部，从而实现round-robin的模式，操作时首先将尾部元素的后续指针指向头部元素，更新尾指针指向原头部元素的后驱指针地址，然后将头部指针指向原头部元素的后驱元素形成新的头部元素（应注意，旋转方法操作时应确保链表中不少于两个线程元素，本调度器在流程机制上保证了这项条件), 最后将原头部元素的后驱指针指向NULL完成旋转操作

- ## **thread_lib类**

`class thread_lib` 是调度器的核心代码，主要实现如下：

```cpp
class thread_lib
{
public:
	static const uint32 high_priority = 0;
	static const uint32 normal_priority = 1;
	static const uint32 low_priority = 2;
	static const uint32 childthreadintetris=lunsizeintetris*threadcountinlun;
#ifdef PROBE_LOG
	uint32 lasttick;
#endif
private:
	static const uint32 maxthread = tetrissizelimitinsystem*(1u+childthreadintetris);
	static thread_lib instance;
	static threadext_dt extcontext[maxthread];
	thread_dt availablecontext[maxthread];
	contextqueue ready_queue[3];//0:high priority   1:normal priority  2:low priority
	thread_dt main_thread;
	contextqueue spare_queue;
	thread_dt *current;
public:
	static contextqueue& get_readyqueue(uint32 priority)

	static contextqueue& get_currentreadyqueue()

	static void reschedule();

	static inline void init()

	static inline thread_dt* getcurrentcontext()

	static inline void __yield()

	static inline void yield()

	static inline void __lowpriorityyield()

	static inline void lowpriorityyield()

	static inline void sleep(uint32 Millisecond = 250)

	static inline void threadexit()

	static inline void reset_threadpool()

	//create_thread should only be called in thread context. Not in interrupt/dpc context.
#ifdef PROBE_LOG
	static void create_thread(const char* funcname,thread_fn thread_start,void* parg, uint32 priority);
#else
	static void create_thread(thread_fn thread_start,void* parg, uint32 priority);
#endif

#ifdef WIN32
	static VOID CALLBACK run_thread(LPVOID pcontext);
#else
	static void run_thread();
#endif

#ifdef PROBE_LOG
	static inline void thread_printf(void);
#endif

};
```

`class thread_lib`提供了调度器工作所必要的成员变量和调度方法

### **调度器成员变量的简要说明**

变量名|功能说明
:--:|--
lasttick|调度器上一次读取的timer计数，代表某时刻系统累积的时间计数，类似Linux 的jiffies
maxthread|定义线程池能支持的最大线程数，这个限制通常取决于平台系统所定义的PID（Process Identify）字段的宽度，在本例取决于处理算力及下游处理能力的带宽极限
instance|所构造的thread lib静态单例，方便将线程池放置于系统规划的快速存储段以加速调度器的调度效能
extcontext|在单例中构造的`class threadext_dt`静态实例数组
availablecontext|在单例中构造的`class thread_dt`静态实例数组
ready_queue|调度器中已注册实际操作任务的线程池，分为high_priority, normal_priority, low_priority三个独立优先级的线程池
main_thread|调度器的主线程，即main函数产生的线程
spare_queue|在单例中构造的线程池，用于存放调度器未注册任务的所有可用空白线程元素 
current|调度器当前在执行的线程元素


### **调度器调度方法的简要说明**

---
操作函数|功能说明
:--:|--
get_readyqueue|获得指定优先级的线程池实例
get_currentreadyqueue|获得当前运行任务所在的优先级线程池实例
reschedule|调度器重调度方法，按照指定的调度策略将当前执行任务占用的处理器计算资源释放，并从ready_queue中选出下一个线程提交到处理器执行 
init|调度器的初始化方法
getcurrentcontext|获得当前正在执行的线程元素的实例
__yield|普通中断模式下的处理器计算资源替换方法，让当前执行的线程任务让出处理器资源，并交给新的线程任务
yield|快速中断模式下的处理器资源替换方法，作用与普通模式下类似
__lowpriorityyield|普通中断模式下的将low priority任务替换当前执行执行任务的方法
lowpriorityyield|快速中断模式下将low priority任务替换当前执行任务的方法
sleep|使当前休眠指定时间的间隔
threadexit|子线程退出执行并返回主线程的方法
reset_threadpool|调度器内部资源的初始化方法
create_thread|注册线程任务到空白线程元素
run_thread|执行线程任务的统一入口
thread_printf|调度器debug使用的打印函数


### 调度器的初始化过程

调度器通过init和reset_threadpool两个函数完成内部资源节点的初始化操作，其中reset_threadpool是init函数调用的子程

`reset_threadpool`函数的源码如下：

```cpp
	static inline void reset_threadpool()
	{
#ifdef WIN32
		for (uint32 i=0; i!=maxthread; ++i)
		{
			LPVOID thread_fiber = instance.availablecontext[i].thread_fiber;
			if (thread_fiber != NULL)
			{
				DeleteFiber(thread_fiber);
			}
		}
#endif
		//memset(&instance,0,sizeof instance);
		memset(&instance,0,sizeof(instance));
		memset(extcontext,0,sizeof(extcontext));
		for(uint32 i = high_priority; i <= low_priority; ++i)
		{
			instance.ready_queue[i].init();
		}
		instance.spare_queue.init();
		for(uint32 i=0; i!=maxthread; ++i)
		{
			instance.availablecontext[i].extdat=&extcontext[i];
			instance.spare_queue.insert(&instance.availablecontext[i]);
		}
	}
```

**上述代码操作流程如下**

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-thread_poolreset-web.jpg)

调度器资源初始化操作将类中使用的静态资源的内存空间段做归0操作，并将线程实例（`class thread_dt`）与线程操作函数实例（`class threadext_dt`）建立一对一绑定产生可用的空白线程元素并加入到spare_queue供调度器随时拾取。采用静态数据资源构建调度器的内部线程资源目的在于提高调度器的工作性能，详细原因将在下文阐述。

`init`函数的源码如下：

```cpp
	static inline void init()
	{
		instance.reset_threadpool();

#ifdef WIN32
		instance.main_thread.thread_fiber = ConvertThreadToFiber(NULL);
		ASSERT(instance.main_thread.thread_fiber != NULL,LEVEL_NORMAL);
#endif

		instance.ready_queue[low_priority].insert(&(instance.main_thread));
		instance.current = &(instance.main_thread);
#ifdef PROBE_LOG
		instance.lasttick = reg_ops::gettickcount();
		instance.current->count = 0;
#endif
	instance.current->priority = low_priority;

	}
```

init函数的流程如下，在调用reset_threadpool初始化资源后，设置主线程和当前线程的状态

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-thread_poolreset-web.jpg)

### 调度器资源的获取
get_readyqueue， getcurrentcontext,, get_currentreadyqueue是调度器三个资源状态获取方法，分别用于获取指定条件下的线程资源

```cpp
static contextqueue& get_readyqueue(uint32 priority)
{
	return instance.ready_queue[priority];
}
static contextqueue& get_currentreadyqueue()
{
	return instance.ready_queue[instance.current->priority];
}
static inline thread_dt* getcurrentcontext()
{
	return instance.current;
}
static inline void __yield()
```

`get_readyqueue`用于获得指定优先级的线程池队列

`get_currentreadyqueue`用于获得当前正在执行线程所在优先级的线程池队列

`getcurrentcontext`用于获得当前正在执行线程的线程对象

### 调度器任务的注册方法

调度器通过`create_thread`函数将用户函数绑定到空白线程对象，并注册到ready_queue线程池中等待调度器提交到处理器执行

```cpp
void thread_lib::create_thread(thread_fn thread_start,void* parg, uint32 priority)
#endif
{
	ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
	ASSERT(priority <= low_priority, LEVEL_NORMAL);
	thread_dt *pcontext = instance.spare_queue.current();
	ASSERT(pcontext!=NULL,LEVEL_NORMAL);
	instance.spare_queue.remove();
	pcontext->next = NULL;
	pcontext->priority = priority;
	pcontext->extdat->thread_start = thread_start;
	pcontext->extdat->thread_arg = parg;
#ifndef WIN32
	memset(pcontext->extdat->astack,0,threadext_dt::thread_stack_size);
#endif // WIN32
#ifdef PROBE_LOG
	pcontext->count = 0;
	memset(pcontext->funcname,' ',sizeof(pcontext->funcname));
	const char* funcnamebody=funcname;
	const char* current=funcname;
	while(*current!='\0')
	{
		if(*current==':')
		{
			funcnamebody=current+1;
		}
		++current;
	}
	for(uint32 i=0;i!=sizeof(pcontext->funcname);++i)
	{
		char deschar=funcnamebody[i];
		if(deschar=='\0')
			break;
		pcontext->funcname[i]=deschar;
	}
#endif
#ifdef WIN32
	pcontext->thread_fiber  = CreateFiber(threadext_dt::thread_stack_size, &run_thread, NULL);
	ASSERT(pcontext->thread_fiber != NULL,LEVEL_NORMAL);
#else
	pcontext->sp = ((uint32)pcontext->extdat->astack)+threadext_dt::thread_stack_size-60;
	pcontext->r15 = (uint32)run_thread-8;
#endif
	uint32 status = clearinterruptacquire();
	instance.ready_queue[priority].insert(pcontext);
	interruptrestore(status);
}
```

流程如下

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-create_thread-web.jpg)

线程栈空间地址以高位地址作为栈底，逐渐向低位地址扩展栈空间范围，在以上代码中，实际的栈空间地址比定义最大栈空间地址小60个byte，目的使不同线程各自的栈空间之间留出足够的安全距离，防止某个线程由于stack overflow crash对其他线程栈区产生破坏性覆盖操作。

按照以上定义，处理通用寄存器文件GPR的第16个寄存器r15存放子过程的返回地址，由于调度器本身属于低级非抢占式调度器，每个线程任务在获得cpu计算资源后将不会被中断打断，一直执行至函数完毕，因此每个子过程的返回地址都被注册到`class thread_lib`的静态成员函数`run_thread`, 具体的原理将在以下调度器过程说明中详细阐述。实际子过程返回地址根据`pcontext->r15 = (uint32)run_thread-8`所示，位于`run_thread`函数label之前一个Dword地址, 这是由于Microblaze处理器的branch模块存在分支预测槽结构（**delay slot**）

**根据Xinlinx MicroBlaze Processor Reference Guide UG984 (v2018.3) Nov 14, 2018, 55页及58页关于分支延迟槽的描述如下**
>
>A control hazard occurs when a branch is taken, and the next instruction is not immediately available. This results in stalling the pipeline. MicroBlaze provides delay slot branches and the optional branch target cache to reduce the number of stall cycles.
>

>
>***Delay Slots***
>
>When executing a taken branch with delay slot, only the fetch pipeline stage in MicroBlaze is flushed. The instruction in the decode stage (branch delay slot) is allowed to complete. This technique effectively reduces the branch penalty from two clock cycles to one. Branch instructions with delay slots have a D appended to the instruction mnemonic. For example, the BNE instruction does not execute the subsequent instruction (does not have a delay slot), whereas BNED executes the next instruction before control is transferred to the branch location.
>
>A delay slot must not contain the following instructions: IMM, IMML, branch, or break. Interrupts and external hardware breaks are deferred until after the delay slot branch has been completed. Instructions that could cause recoverable exceptions (for example unaligned word or halfword load and store) are allowed in the delay slot.
>If an exception is caused in a delay slot the ESR[DS] bit is set, and the exception handler is responsible for returning the execution to the branch target (stored in the special purpose register BTR). If the ESR[DS] bit is set, register R17 is not valid (otherwise it contains the address following the instruction causing the exception).
>
**存在分支预测槽结构的处理器，在执行branch类指令时，由于取指单元（IFU， Instruction Fetch Unit）预取的指令缓存会清空，导致IFU需要重新预取新的有效指令，因此跳转指令的效果会延迟数个cycle才能生效，从而在流水线上产生若干个cycle的空泡（bubble），为了遮盖这些流水线空泡，处理器会提前执行跳转指令之后的数条指令，因此对应上文赋值给r15的返回地址将比实际的`run_thread`地址提前两个指令左右的执行宽度，用于配合分支延迟槽的提前执行特征**

### 调度器的操作方法
调度器的操作方法主要有如下几种

- **线程重调度方法`reschedule`**
- **线程让步方法`yield, __yield, lowpriorityyield, __lowpriorityyield`**
- **线程任务执行方法`run_thread`**
- **线程任务推出方法`threadexit`**
- **线程休眠方法`sleep`**


#### 线程重调度函数 ***reschedule*** 

函数实现的代码如下

```cpp
void thread_lib::reschedule()
{
	thread_dt *pnewctx;
#ifdef PROBE_LOG
	uint32 curtick=reg_ops::gettickcount();
	instance.current->count += curtick - instance.lasttick;
	do
	{
		communicator::overheat_delay();
		if(laterthan(reg_ops::gettickcount(),currenttick))
		{
			uint32 newtick=reg_ops::gettickcount();
			accidletime+=newtick-curtick;
			curtick=newtick;
			disp_diagnoisisinfo();
		}
	}
	while((pnewctx = instance.ready_queue[high_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[normal_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[low_priority].current())==NULL);
	{
		uint32 newtick=reg_ops::gettickcount();
		accidletime+=newtick-curtick;
		instance.lasttick = newtick;
	}
#else
	do
	{
		communicator::overheat_delay();
	}
	while((pnewctx = instance.ready_queue[high_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[normal_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[low_priority].current())==NULL);
#endif
#ifdef WIN32
	instance.current = pnewctx;
	LPVOID next_fiber =instance.current->thread_fiber;
	ASSERT(next_fiber != NULL,LEVEL_NORMAL);
	SwitchToFiber(next_fiber);
#else
	thread_dt *poldctx = instance.current;
	instance.current = pnewctx;
	__Yield(poldctx,pnewctx);
#endif
}
```

重调度函数实现的功能非常简单, 即按照从高到低的优先级从ready_queue线程池中取出下一个即将执行的线程元素，并使其获得当前正在执行线程所让步出处理器计算资源, 图示流程如下。

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-reshudule-web.jpg)

过温判断是一个阻塞式的函数调用过程,当通过CPU读取到系统中温度传感器（Temperature Sendor）读数高过预设的过温阈值时，CPU需要循环进入`nop`指令以等待系统温度降低到安全阈值以下,等待函数`overheat_delay`的代码如下

```cpp
static inline void overheat_delay()
	{
		//Wait for a certain period of time.
		//1/2 CPU computation power.
		uint32 isrflag=clearinterruptacquire();
		uint32 tick=reg_ops::gettickcount();
		uint32 interval = timeinterval(instance.last_ohdelay_tick, tick);
		interval=Min(interval,reg_ops::tick_size*max_ohdelay_interval);
		uint32 tickguard=tick+interval;
		while(beforethan(reg_ops::gettickcount(),tickguard));
		instance.last_ohdelay_tick=reg_ops::gettickcount();
		interruptrestore(isrflag);
	}
```

在执行等待过程中，需要将系统的中断响应使能关闭,防止意外中断的介入打断系统降温过程。在过程中，系统需要读入实时计数器（Timer/R， Real Timer Clock）的当前计数，与预设的降温等待间隔累加计算得到tickguard值，当系统polling到的tick计数小于tickguard时，全系统除CPU外，业务均处于pending状态。tick 的概念类似Linux 系统中所提出的jiffies概念，即系统开机后，一段时间内累计的总时间周期基数，该计数用于系统执行一些延迟等待任务。

整个重调度函数的核心部分是用于执行线程替换的内嵌ASM函数`__Yield`



`Yield`函数使用内嵌式汇编调用接口,其接口形式如下

`extern void __Yield(thread_dt* poldctx,thread_dt* pnewctx);`

内嵌式汇编程序的参数传递方式一般有三种，常用的有通过汇编占位符方式引入参数和通过处理器paramerter寄存器引入参数。

通过汇编占位符引入参数的内联汇编格式如下

```x86asm
__asm__　__volatile__("Instruction List" : Output : Input : Clobber/Modify);
```

- **Instruction List**

Instruction List 是汇编指令序列。它可以是空的，比如：__asm__ __volatile__(""); 或 __asm__ ("");都是完全合法的内联汇编表达式

- **__volatile__**

__volatile__是GCC 关键字volatile 的宏定义
`#define __volatile__ volatile` __volatile__或volatile 是可选的。如果用了它，则是向GCC 声明不允许对该内联汇编优化

- **Output**

Output 用来指定当前内联汇编语句的输出

- **Input**

Input 域的内容用来指定当前内联汇编语句的输入Output和Input中，格式为形如“constraint”(variable)的列表（逗号分隔)

- **Clobber/Modify**
  
有时候，你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改，希望GCC在编译时能够将这一点考虑进去。那么你就可以在Clobber/Modify域声明这些寄存器或内存。这种情况一般发生在一个寄存器出现在"Instruction List"，但却不是由Input/Output操作表达式所指定的，也不是在一些Input/Output操作表达式使用"r"约束时由GCC 为其选择的，同时此寄存器被"Instruction List"中的指令修改，而这个寄存器只是供当前内联汇编临时使用的情况。


- **通用约束**
约束 Input/Output 意义 g I,O 表示可以使用通用寄存器，内存，立即数等任何一种处理方式。 0,1,2,3,4,5,6,7,8,9 I 表示和第n个操作表达式使用相同的寄存器/内存

例如：
```x86asm
__asm__ ("popl %0 \n\t"
		 "movl %1, %%esi \n\t"
		 "movl %2, %%edi \n\t": 
		 "=a"(__out): 
		 "r" (__in1), 
		 "r" (__in2));
```
此例中，%0对应的就是Output操作表达式，它被指定的寄存器是%eax，整个Instruction List的第一条指令popl %0，编译后就成为popl %eax，这时%eax的内容已经被修改，随后在Instruction List后，GCC会通过movl %eax, address_of_out这条指令将%eax的内容放置到Output变量__out中。对于本例中的两个Input操作表达式而言，它们的寄存器约 束为"r"，即要求GCC为其指定合适的寄存器，然后在Instruction List之前将__in1和__in2的内容放入被选出的寄存器中，如果它们中的一个选择了已经被__out指定的寄存器%eax，假如是__in1，那 么GCC在Instruction List之前会插入指令movl address_of_in1, %eax，那么随后popl %eax指令就修改了%eax的值，此时%eax中存放的已经不是Input变量__in1的值了，那么随后的movl %1, %%esi指令，将不会按照我们的本意——即将__in1的值放入%esi中——而是将__out的值放入%esi中了。

而`__Yield`函数的实现采用的是通过处理器parameter寄存器传参的方式, 根据**Xinlinx MicroBlaze Processor Reference Guide UG984 (v2018.3) Nov 14, 2018** 195页描述, r5-r10是Mircoblaze处理器GPR中的参数寄存器，引入参数按照形参顺序依次放入寄存器位置

![registerparam](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-yield-register-web.jpg)

在本例中使用r5和r6两枚参数寄存器分别存放poldctx与pnewctx指针, 调用`swi` save 指令按照class/struct内存排布结构，依次向内存段存入当前GPR的保存内容到poldctx指定空间,同时使用`lwi` load 指令将新线程中的上下文内容换入到处理器的上下文空间环境内。对于`class thread_dt`的实例其内存中的排布结构如下所示：

![classstruct](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post_bg_class_struct_web.jpg)

以上结构为`class thread_dt`在实例在内存中的排布结构，由于线程池元素构造了类的实例对象数组，因此在内存构造中没有this指针的构造内存空间。 

`__Yield`函数的源码实现如下

```avrasm
	.section .text
	.globl	__Yield
	.align	4
    .ent	__Yield
        .type __Yield, @function
__Yield:
	//save registers
	swi	r15,r5,4
	swi	r17,r5,8
	swi	r19,r5,12
	swi	r20,r5,16
	swi	r21,r5,20
	swi	r22,r5,24
	swi	r23,r5,28
	swi	r24,r5,32
	swi	r25,r5,36
	swi	r26,r5,40
	swi	r27,r5,44
	swi	r28,r5,48
	swi	r29,r5,52
	swi	r30,r5,56
	swi	r31,r5,60
	//store R1 in *poldctx->sp
	swi	r1,r5,0
	//set R1 to *pnewctx->sp
	lwi	r1,r6,0
	//restore registers
	lwi	r15,r6,4
	lwi	r17,r6,8
	lwi	r19,r6,12
	lwi	r20,r6,16
	lwi	r21,r6,20
	lwi	r22,r6,24
	lwi	r23,r6,28
	lwi	r24,r6,32
	lwi	r25,r6,36
	lwi	r26,r6,40
	lwi	r27,r6,44
	lwi	r28,r6,48
	lwi	r29,r6,52
	lwi	r30,r6,56
	rtsd	r15,8
	lwi	r31,r6,60
	.end	__Yield
```

代码中 "`.section .text`" 表示该段代码位于程序的text段，即指令正文， "`.globl	__Yield`" 表示函数的label名 __Yield全局空间可见，以方便链接器按名字执行链接操作，”`.align	4`“ 表示生成的二进制代码按照4字节对齐排布，对应microblaze作为RISC 32处理的标准格式 ”`.ent	__Yield`“表示作为__Yield程序的正文起始，函数正文从此开始 ”`.type __Yield, @function`"用于指定代码的类型，`__Yield`部分代码属于函数子程。"`.end	__Yield`"表示整个函数的结尾。

`__Yield`函数首先调用`swi`指令将以r15开始的15个上下文GPR内容保存到poldxtx内存段以+4偏址至+60偏址的这部分空间,最后把栈空间指针从r1复制到poldxtx内存段+0偏址完成现有进程的上下文保存。

新线程任务的注入的过程与保存过程相反，调用`lwi`指令首先将pnewxtx内存段以+0偏址的栈空间地址复制到r1寄存器 然后将以r15开始的15个上下文GPR内容从pnewctx的+4至+60偏址复制到处理器对应GPR, 然后使用`rtsd`将PC指针重定向到r15返回地址+8的位置，按照上文所提，`r15=run_thread=8`,因此重定向的PC指针地址为`run_thread`函数的统一入口地址。可以看到`rtsd` 分支指令提前到 `lwi r31, r6,60`指令前执行，其原因在于上文所提到的分支预测槽的影响，由于rtsd指令需要至少延迟一个指令周期才能生效，为了有效利用延迟带来的空泡，故将`rtsd`指令提前一个周期执行，使延迟时间槽正好被下一条指令的执行时间所填满,在调度器频繁使用线程切换时，可以提高一定的指令执行的效率。

#### 线程让步函数  



















