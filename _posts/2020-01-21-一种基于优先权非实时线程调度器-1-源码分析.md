---
layout:     post
title:      非实时优先权线程调度器-源码分析
subtitle:   嵌入式开发 内核进阶
date:       2020-01-21
author:     Shawn.Tan
header-img: img/post-bg-scheduler3-web.jpg
catalog: true
tags:
    - 嵌入式
    - SSD
    - CPU架构
    - 操作系统
    - RISC-V
---
# 前言

**调度器**(**scheduler**)是计算机操作系统内核中对进程/线程分配CPU计算资源的重要模块

![调度器功能](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-sheduler-structure-web1.jpg)

在桌面机，嵌入式设备或大型机等不同的应用环境中，产生了不同类型资源分配策略的调度器，针对不同层面分为以下几种调度器

- **高级调度器（long-term scheduler）：** 通常用于面向批处理的多程序环境中，通过均衡内存中的任务以优化系统资源，包括CPU，内存和硬盘存储等。

- **中级调度器（medium-term scheduler）：** 跟踪CPU上执行的进程/线程的动态内存用量来决定是否要增加或减少“多通道程度“（内存中竞争CPU的进程个数），以防止”颠簸“。颠簸即当前的进程集合的内存需求超过了系统容量，导致进程在各自的执行中变得缓慢。

- **低级调度器（short-term scheduler）：** 负责在当前驻留的内存里的进程/线程中选择一个来运行。这篇内容设计的算法主要关注的都是低级调度器

**在之前的项目工作中研究了一种部署在Xilinx MicroBlaze 嵌入式平台中的低级调度器**，计划按以下四个部分介绍该调度器的具体实现和改进实验

1. 调度器源码分析
2. 基于VEGA织女星NXP-RVM1-Series RI5CY平台的调度器移植实验
3. 基于中断时间片的调度器改进实验
4. 调度器性能分析

**本篇文章为第一部分将分析该调度器的源码实现。** 在低级调度器中，一般划分为：**非抢占式**和**抢占式**。非抢占式的调度器中，一个进程/线程或采用执行到底策略，或主动释放资源放弃占用处理器时间以处理I/O请求，调度器只负责安排进程/线程执行顺序；而抢占式调度器则从主动从当前线程手中把处理器计算资源抢走，并交给另一个进程/线程使用。不管是哪一类调度器都会按照以下四项开展调度工作：

- 获得处理器的控制权
- 保存当前正在运行的进程/线程状态（PCB，process control block）
- 选择一个新的进程/线程来执行
- 提交新选择出来的进程/线程给处理器运行，将该进程/线程的PCB状态加载到CPU寄存器中
   
进程/线程状态包含了程序执行中的关键信息，例如当前程序执行位置（PC指针），过程调用（sub-routine）返回地址，程序在存储空间的现场（**contex**，程序上下文）等等，是调度器执行调度任务的重要信息部分。

# 源码分析

## 基本结构

调度器由以下6个基本类组成

类名|功能说明
:--:|--
thread_dt|装载任务线程thread的运行状态（PCB）
threadext_dt|指定任务线程thread的栈（stack）空间，管理线程函数的函数指针及参数
contexqueue|管理PCB线程池的单向链表队列
thread_lib|调度器的核心类，包含调度器线程管理的所有方法和线程资源池
event_dt|线程事件的实现类，包含事件的实现方法及操作函数
semaphore_dt|信号量旗语的实现类，包含信号量的实现及操作方法

`class thread_lib`是整个调度器的核心类，下图为整个调度器的组织结构

![调度器结构关系](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-threadlib-web.jpg)

## 代码分析

- ### **thread_dt类**

`class thread_dt`是上文所提到的PCB内容的容器，其实现代码如下：

```cpp
class thread_dt
{
public:
#ifdef WIN32
	LPVOID thread_fiber;
#else
	uint32 sp;             //栈指针
	union
	{
		uint32 reg[15];    //部分CPU通用寄存器保存
		struct
		{
			uint32 r15;    //sub-routine结束后的返回地址, 在microblaze体系中，r15用于保存返回地址
			uint32 r17;
			uint32 r19;
			uint32 r20;
			uint32 r21;
			uint32 r22;
			uint32 r23;
			uint32 r24;
			uint32 r25;
			uint32 r26;
			uint32 r27;
			uint32 r28;
			uint32 r29;
			uint32 r30;
			uint32 r31;
		};
	};
#endif
	threadext_dt *extdat;    //线程任务的操作类指针
	thread_dt *next;         //线程池链表的尾指针
   	uint32 priority;         //任务的优先级
#ifdef PROBE_LOG
	uint32 count;
	char funcname[12];
#endif
};
```

`class thread_dt`保存了线程运行的所有关键现场信息，包括以下5部分

1. 部分CPU通用寄存器（GPR， General Purpose Register）的当前状态  
2. 程序计数器的当前指令执行地址，用与产生sub-routine结束后的返回地址
3. 栈（Stack）指针 
4. 线程任务的操作内容对象指针
5. 线程任务优先级 

通过上述五部分所描述的线程上下文现场信息，处理器可以切换到指定sub-routine执行新的任务。通常寄存器文件信息只需保存两类寄存器作为关键现场信息：由**Saving Registers**与**Temporry Registers**

![microbalze寄存器功能描述](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-mb_registers_web.jpg)

按上图给出的定义所以对线程执行现场的保存需要保存**r15，r17，r19-r31**等15个必要GPR寄存器 


- ### **threadext_dt类**

`class threadext_dt`是线程任务函数的容器，其实现代码如下：

```cpp
class threadext_dt
{
public:
	static const uint32 thread_stack_size = 520284; //Near 512k. Not exactly 512k to avoid cache collision.  栈空间大小
#ifndef WIN32
	uint8 astack[thread_stack_size];  //栈空间
#endif
	thread_fn thread_start;           //线程任务函数指针
	void *thread_arg;                 //线程任务函数参数
};
```

`class threadext_dt` 保存的内容主要有三点：

1. 线程的栈空间内容
2. 任务线程函数指针，该指针在具体的线程任务创建时需要和实际的执行函数地址绑定，所支持的线程函数格式要求如下：
   **`void (*thread_fn)(void *arg)`**
3. 任务线程函数的参数列表指针

线程空间所制定的栈空间大小比cache的物理尺寸(512KB)少一个内存页框（page frame， 4KB）的大小。这种设计的目的在于当cache基于4KB大小的cacheline做刷新时，cache通过DataBus总线访问主存的最大单次数据传输宽度为256bit*16等于4KB。当cache miss时，cache可直接使用这个多余的空cacheline从主存调入新块，并更新cam表映射，上述情况可在Data Cache Miss的数据量小于一个物理页范围时减少一次Cache Line的Write Back操作，从而减少Cache Miss带来的访存延迟惩罚（penalty）。由于上述线程的保存并没有利用线程任务的PID，因此在线程任务在切换时，前面线程存放于cache的数据对当前线程均miss，因此在存储切换时可能有较大由于cache warm up所带来的访存颠簸。

- ## **contextqueue类**

`class contexqueue`实现了对线程池的管理功能， 其实现代码如下：

```cpp
class contextqueue
{
private:
	thread_dt* volatile head;
	thread_dt* volatile * volatile tail;

public:
	inline void init()
	{
		head = NULL;
		tail = &head;
	}

	inline thread_dt* volatile current()
	{
		return head;
	}

	inline void insert(thread_dt* c)
	{
		c->next = NULL;
		*tail = c;
		tail = &c->next;
	}

	inline void inserthead(thread_dt* c)
	{
		c->next = head;
		if(head == NULL)
		{
			tail = &c->next;
		}
		head = c;
	}

	inline void batchinsert(contextqueue &addqueue)
	{
		ASSERT(addqueue.head != NULL,LEVEL_NORMAL);
		*tail = addqueue.head;
		tail = addqueue.tail;
	}

	inline void remove()
	{
		if ((head = head->next) == NULL)
		{
			tail = &head;
		}
	}

	inline void removeall()
	{
		init();
	}

	inline void rotate()
	{
		ASSERT(head != NULL,LEVEL_NORMAL);
		*tail = head;
		tail = &head->next;
		head = head->next;
		*tail = NULL;
	}
};
```
上述线程池为单向链表结构，并提供了8种资源管理方法

函数名|功能简介
:--:|--
init()|线程池的初始化方法
current()|返回线程池链表的头部元素指针
insert()|在线程池链表尾部插入新的线程元素
inserthead()|在线程池链表的头部插入新的线程元素
batchinsert()|在线程池链表的尾部插入新的线程池链表
remove()|删除线程池链表的头部元素
removeall()|删除整个线程池链表（重新初始化线程池）
retate()|线程池的初始化方法
init()|线程池的初始化方法





