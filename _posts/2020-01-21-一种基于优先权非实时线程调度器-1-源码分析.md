---
layout:     post
title:      非实时优先权线程调度器-源码分析
subtitle:   嵌入式开发 内核进阶
date:       2020-01-21
author:     Shawn.Tan
header-img: img/post-bg-scheduler3-web.jpg
catalog: true
tags:
    - 嵌入式
    - SSD
    - CPU架构
    - 操作系统
    - RISC-V
---
# 前言
**调度器（scheduler**是计算机操作系统内核对进程或线程分配CPU计算资源的基本模块。
![调度器功能](img/post-sheduler-structure-web1.jpg)

在桌面机，嵌入式设备或大型机等不同的应用环境中，产生了不同类型的资源分配策略的调度器，针对不同层面，分为以下几种调度器

**1. 高级调度器（long-term scheduler）：** 通常用于面向批处理的多程序环境中，通过均衡内存中的任务以欧化系统资源，包括CPU，内存和硬盘存储等。
**2. 中级调度器（medium-term scheduler）：** 跟踪CPU上执行的进程的动态内存用量来决定是否要增加或减少“多通道程度“（内存中竞争CPU的进程个数），以防止”颠簸“。颠簸即当前的进程集合的内存需求超过了系统容量，导致进程在各自的执行中变得缓慢。
**3. 低级调度器（short-term scheduler）：** 负责在当前驻留的内存里的进程中选择一个来运行。这篇内容设计的算法主要关注的都是低级调度器

**在之前的项目工作中研究了一种部署在Xilinx MicroBlaze 嵌入式CPU平台中的低级调度器**，计划按以下四个部分介绍该调度器的具体实现和改进实验

1. 调度器源码分析
2. 基于VEGA织女星NXP-RVM1-Series RI5CY平台的调度器移植实验
3. 基于中断时间片的调度器改进实验
4. 调度器性能分析

**本篇文章为第一部分主要分析调度器的源码实现。** 在低级调度器中，一般划分为：非抢占式和抢占式。非抢占式的调度器中，一个进程要不然就一直执行到底，要不然就自己主动资源放弃处理器，以处理I/O请求，调度器只是安排先后顺序；而抢占式调度器里，调度器从当前进程手中把处理器抢走，交给另一个进程，有这么一个主动的动作。不管是哪一种，调度器的执行步骤一般如下：

1. 获得处理器的控制权
2. 把当前正在运行的进程状态（PCB，process control block）保存下来
3. 选择一个新的进程来执行
4. 把新选择出来的进程分发给处理器运行，这一步会把第二步中的状态再加载到CPU寄存器中。
可以看出，在调度器调度过程中，进程状态很重要，它包括了很多信息：当前的程序执行位置（PC指针）作为子过程（sub-routine）的返回地址依据，程序在存储空间的现场（contex，上下文现场）等等。以下内容将就上述四个步骤分析调度器的实现结构


# 源码分析

## 基本结构

调度器由以下6个基本类组成

类名|功能说明
:--:|--
thread_dt|装载任务进程thread的运行状态（PCB）
threadext_dt|指定任务进程thread的栈（stack）空间，管理进程函数的函数指针及参数
contexqueue|管理PCB线程池的单向链表队列
thread_lib|调度器的核心类，包含调度器线程管理的所有方法和线程资源池
event_dt|进程事件的实现类，包含事件的实现方法及操作函数
semaphore_dt|信号量旗语的实现类，包含信号量的实现及操作方法

`class thread_lib`是整个调度器的核心类，下图为整个调度器的组织结构

![调度器结构关系](img/post-bg-threadlib-web.jpg)

## 代码分析

### thread_dt类

`class thread_dt`是上文所提到的PCB内容的容器，其实现代码如下：

(```)
    class thread_dt
    {
    public:
    #ifdef WIN32
    	LPVOID thread_fiber;
    #else
    	uint32 sp;             //栈（Stack）指针
    	union
    	{
    		uint32 reg[15];    //部分CPU通用寄存器（GPR， General Purpose Register）的当前状态
    		struct
    		{
    			uint32 r15;    //sub-routine结束后的返回地址, 在microblaze体系中，**r15**用于保存返回地址
    			uint32 r17;
    			uint32 r19;
    			uint32 r20;
    			uint32 r21;
    			uint32 r22;
    			uint32 r23;
    			uint32 r24;
    			uint32 r25;
    			uint32 r26;
    			uint32 r27;
    			uint32 r28;
    			uint32 r29;
    			uint32 r30;
    			uint32 r31;
    		};
    	};
    #endif
    	threadext_dt *extdat;    //进程任务的操作类指针
    	thread_dt *next;         //进程池链表的尾指针
       	uint32 priority;         //任务的优先级
    #ifdef PROBE_LOG
    	uint32 count;
    	char funcname[12];
    #endif
};
(```)

`class thread_dt`的主要作用是保存程序运行的现场信息，主要的内容包括以下5部分

1. 部分CPU通用寄存器（GPR， General Purpose Register）的当前状态  
2. 程序计数器所指示的当前指令地址，用来产生sub-routine结束以后的返回地址
3. 栈（Stack）指针 
4. 进程任务的操作类指针
5. 任务的优先级 

`class thread_dt`是一个容器类.所包含的五个部分描述了计算机任务进程执行过程所必须上下文信息，通过这些信息，处理器可以跳转到指定sub-routine执行任务，一般情况下，在现场保存时，只需复制GPR寄存器文件的两类寄存器，**Saving Rigisters**与**Temporry Register**

![microbalze寄存器功能描述](img/post-bg-mb_registers_web.jpg)

因此保存microblaze的**r15，r17，r19-r31**等15个必须的GPR寄存器 


### threadext_dt类

`class threadext_dt`是进程任务函数的容器，其实现代码如下：

(```)
    class threadext_dt
    {
    public:
    	static const uint32 thread_stack_size = 520284; //Near 512k. Not exactly 512k to avoid cache collision.  //栈空间大小
    #ifndef WIN32
    	uint8 astack[thread_stack_size];  //栈空间
    #endif
    	thread_fn thread_start;           //进程任务函数指针
    	void *thread_arg;                 //进程任务函数参数
    };
(```)

`class threadext_dt` 保存的内容主要有三点：

1. 线程的栈空间内容
2. 任务进程函数指针，该指针在具体的线程任务创建时需要和实际的执行函数地址绑定，所支持的进程函数格式要求如下：
   `void (*thread_fn)(void *arg)`
3. 任务进程函数的参数列表指针

上述代码指定堆空间大小比cache的物理尺寸（512KB）略小一个4KB，相当于一个内存页框（page frame）大小，当cache基于4KB cacheline大小做刷新时，系统总线访问单笔数据宽度为256bit*16的burst length对于一个4KB的大小。当访问数据出现cache miss情况，cache可直接使用这个多余的空块从主存做新块的调换，然后在cam表更新映射，该操作在小于一个page的数据存在cache miss的情况下，在CPU IO端减少一次Write Back操作，从而减少Cache Miss带来的惩罚（penalty）。线程任务在切换时，前次任务所cache的数据均为无效，因此在存储切换时可能有比较大由于cache warm up带来的数据颠簸。






