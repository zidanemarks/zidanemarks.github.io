---
layout:     post
title:      非实时优先权线程调度器-源码分析
subtitle:   嵌入式开发 内核进阶
date:       2020-01-21
author:     Shawn.Tan
header-img: img/post-bg-scheduler3-web.jpg
catalog: true
tags:
    - 嵌入式
    - SSD
    - CPU架构
    - 操作系统
    - RISC-V
---
# 前言

**调度器**(**scheduler**)是计算机操作系统内核中对进程/线程分配CPU计算资源的重要模块

![调度器功能](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-sheduler-structure-web1.jpg)

在桌面机，嵌入式设备或大型机等不同的应用环境中，产生了不同类型资源分配策略的调度器，针对不同层面分为以下几种调度器

- **高级调度器（long-term scheduler）：** 通常用于面向批处理的多程序环境中，通过均衡内存中的任务以优化系统资源，包括CPU，内存和硬盘存储等。

- **中级调度器（medium-term scheduler）：** 跟踪CPU上执行的进程/线程的动态内存用量来决定是否要增加或减少“多通道程度“（内存中竞争CPU的进程个数），以防止”颠簸“。颠簸即当前的进程集合的内存需求超过了系统容量，导致进程在各自的执行中变得缓慢。

- **低级调度器（short-term scheduler）：** 负责在当前驻留的内存里的进程/线程中选择一个来运行。这篇内容设计的算法主要关注的都是低级调度器

**在之前的项目工作中研究了一种部署在Xilinx MicroBlaze 嵌入式平台中的低级调度器**，计划按以下四个部分介绍该调度器的具体实现和改进实验

1. 调度器源码分析
2. 基于VEGA织女星NXP-RVM1-Series RI5CY平台的调度器移植实验
3. 基于中断时间片的调度器改进实验
4. 调度器性能分析

**本篇文章为第一部分将分析该调度器的源码实现。** 在低级调度器中，一般划分为：**非抢占式**和**抢占式**。非抢占式的调度器中，一个进程/线程或采用执行到底策略，或主动释放资源放弃占用处理器时间以处理I/O请求，调度器只负责安排进程/线程执行顺序；而抢占式调度器则从主动从当前线程手中把处理器计算资源抢走，并交给另一个进程/线程使用。不管是哪一类调度器都会按照以下四项开展调度工作：

- 获得处理器的控制权
- 保存当前正在运行的进程/线程状态（PCB，process control block）
- 选择一个新的进程/线程来执行
- 提交新选择出来的进程/线程给处理器运行，将该进程/线程的PCB状态加载到CPU寄存器中
   
进程/线程状态包含了程序执行中的关键信息，例如当前程序执行位置（PC指针），过程调用（sub-routine）返回地址，程序在存储空间的现场（**context**，程序上下文）等等，是调度器执行调度任务的重要信息部分。

# 源码分析

## 基本结构

调度器由以下6个基本类组成

类名|功能说明
:--:|--
thread_dt|装载任务线程thread的运行状态（PCB）
threadext_dt|指定任务线程thread的栈（stack）空间，管理线程函数的函数指针及参数
contexqueue|管理PCB线程池的单向链表队列
thread_lib|调度器的核心类，包含调度器线程管理的所有方法和线程资源池
event_dt|线程事件的实现类，包含事件的实现方法及操作函数
semaphore_dt|信号量旗语的实现类，包含信号量的实现及操作方法

`class thread_lib`是整个调度器的核心类，下图为整个调度器的组织结构

![调度器结构关系](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-threadlib-web.jpg)

## 代码分析

- ### **thread_dt类**

`class thread_dt`是上文所提到的PCB内容的容器，实现如下：

```cpp
class thread_dt
{
public:
#ifdef WIN32
	LPVOID thread_fiber;
#else
	uint32 sp;             //栈指针
	union
	{
		uint32 reg[15];    //部分CPU通用寄存器保存
		struct
		{
			uint32 r15;    //sub-routine结束后的返回地址, 在microblaze体系中，r15用于保存返回地址
			uint32 r17;
			uint32 r19;
			uint32 r20;
			uint32 r21;
			uint32 r22;
			uint32 r23;
			uint32 r24;
			uint32 r25;
			uint32 r26;
			uint32 r27;
			uint32 r28;
			uint32 r29;
			uint32 r30;
			uint32 r31;
		};
	};
#endif
	threadext_dt *extdat;    //线程任务的操作类指针
	thread_dt *next;         //线程池链表的尾指针
   	uint32 priority;         //任务的优先级
#ifdef PROBE_LOG
	uint32 count;
	char funcname[12];
#endif
};
```

`class thread_dt`保存了线程运行的所有关键现场信息，包括以下5部分

1. 部分CPU通用寄存器（GPR， General Purpose Register）的当前状态  
2. 程序计数器的当前指令执行地址，用与产生sub-routine结束后的返回地址
3. 栈（Stack）指针 
4. 线程任务的操作内容对象指针
5. 线程任务优先级 

通过上述五部分所描述的线程上下文现场信息，处理器可以切换到指定sub-routine执行新的任务。通常寄存器文件信息只需保存两类寄存器作为关键现场信息：由**Saving Registers**与**Temporry Registers**

![microbalze寄存器功能描述](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-mb_registers_web.jpg)

按上图给出的定义所以对线程执行现场的保存需要保存**r15，r17，r19-r31**等15个必要GPR寄存器 


- ### **threadext_dt类**

`class threadext_dt`是线程任务函数的容器，其实现代码如下：

```cpp
class threadext_dt
{
public:
	static const uint32 thread_stack_size = 520284; //Near 512k. Not exactly 512k to avoid cache collision.  栈空间大小
#ifndef WIN32
	uint8 astack[thread_stack_size];  //栈空间
#endif
	thread_fn thread_start;           //线程任务函数指针
	void *thread_arg;                 //线程任务函数参数
};
```

`class threadext_dt` 保存的内容主要有三点：

1. 线程的栈空间内容
2. 任务线程函数指针，该指针在具体的线程任务创建时需要和实际的执行函数地址绑定，所支持的线程函数格式要求如下：
   **`void (*thread_fn)(void *arg)`**
3. 任务线程函数的参数列表指针

线程空间所制定的栈空间大小比cache的物理尺寸(512KB)少一个内存页框（page frame， 4KB）的大小。这种设计的目的在于当cache基于4KB大小的cacheline做刷新时，cache通过DataBus总线访问主存的最大单次数据传输宽度为256bit*16等于4KB。当cache miss时，cache可直接使用这个多余的空cacheline从主存调入新块，并更新cam表映射，上述情况可在Data Cache Miss的数据量小于一个物理页范围时减少一次Cache Line的Write Back操作，从而减少Cache Miss带来的访存延迟惩罚（penalty）。由于上述线程的保存并没有利用线程任务的PID，因此在线程任务在切换时，前面线程存放于cache的数据对当前线程均miss，因此在存储切换时可能有较大由于cache warm up所带来的访存颠簸。

- ## **contextqueue类**

`class contexqueue`实现了对线程池的管理功能， 实现如下：

```cpp
class contextqueue
{
private:
	thread_dt* volatile head;
	thread_dt* volatile * volatile tail;

public:
	inline void init()
	{
		head = NULL;
		tail = &head;
	}

	inline thread_dt* volatile current()
	{
		return head;
	}

	inline void insert(thread_dt* c)
	{
		c->next = NULL;
		*tail = c;
		tail = &c->next;
	}

	inline void inserthead(thread_dt* c)
	{
		c->next = head;
		if(head == NULL)
		{
			tail = &c->next;
		}
		head = c;
	}

	inline void batchinsert(contextqueue &addqueue)
	{
		ASSERT(addqueue.head != NULL,LEVEL_NORMAL);
		*tail = addqueue.head;
		tail = addqueue.tail;
	}

	inline void remove()
	{
		if ((head = head->next) == NULL)
		{
			tail = &head;
		}
	}

	inline void removeall()
	{
		init();
	}

	inline void rotate()
	{
		ASSERT(head != NULL,LEVEL_NORMAL);
		*tail = head;
		tail = &head->next;
		head = head->next;
		*tail = NULL;
	}
};
```
上述线程池为单向链表结构，并提供了8种资源管理方法

函数名|功能简介
:--:|--
init()|线程池的初始化方法
current()|返回线程池链表的头部元素指针
insert()|在线程池链表尾部插入新的线程元素
inserthead()|在线程池链表的头部插入新的线程元素
batchinsert()|在线程池链表的尾部插入新的线程池链表
remove()|删除线程池链表的头部元素
removeall()|删除整个线程池链表（重新初始化线程池）
retate()|线程池的初始化方法
init()|线程池的初始化方法

### 线程池init方法

![init](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-cq-init-web.jpg)

线程池的初始化方法通过首尾指针构造了一个以`class thread_dt`对象为元素的空白单向链表结构，头部指针指向一个NULL对象，尾部的二级指针指向头部指针地址的位置。

### 线程池insert方法

![insert](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-cq-insert-web.jpg)

线程池对象的插入方法将原线程池尾部元素的后驱指针连接到新元素，移动尾部指针的指向新元素的后驱指针位置，尾部元素的后驱指针需要指向NULL

### 线程池inserthead方法

![inserthead](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-inserthead-web.jpg)

线程池的头部插入方法将新元素的后驱指针指向原链表的头部，特别在空表插入情况下，需要将尾部指针定位到新元素的后驱指针地址位置，最后更新头部指针指向新元素即可

### 线程池batchinsert方法

![batchinsert](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-batchinsert-web.jpg)

对线程池尾部插入一个线程链表需将尾指针指向新链表的头部元素，同时移动尾指针执行新链表的尾部元素的后驱指针

### 线程池remove方法

![remove](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-remove-web.jpg)

线程池链表元素的删除总是删除头部元素，当删除后为非空链表，只需将头部指针移向原头部的后续元素，当出现删空时，则还需要将尾部指针也指向原头部后驱指针的地址位置

### 线程池removeall方法

等同于重新初始化线程池

### 线程池rotate方法

![rotate](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-rotate-web.jpg)

线程池的元素旋转方法是调度器的调度策略的重要操作，目的使原链表的头部元素被替换到尾部，从而实现round-robin的模式，操作时首先将尾部元素的后续指针指向头部元素，更新尾指针指向原头部元素的后驱指针地址，然后将头部指针指向原头部元素的后驱元素形成新的头部元素（应注意，旋转方法操作时应确保链表中不少于两个线程元素，本调度器在流程机制上保证了这项条件), 最后将原头部元素的后驱指针指向NULL完成旋转操作

- ## **thread_lib类**

`class thread_lib` 是调度器的核心代码，主要实现如下：

```cpp
class thread_lib
{
public:
	static const uint32 high_priority = 0;
	static const uint32 normal_priority = 1;
	static const uint32 low_priority = 2;
	static const uint32 childthreadintetris=lunsizeintetris*threadcountinlun;
#ifdef PROBE_LOG
	uint32 lasttick;
#endif
private:
	static const uint32 maxthread = tetrissizelimitinsystem*(1u+childthreadintetris);
	static thread_lib instance;
	static threadext_dt extcontext[maxthread];
	thread_dt availablecontext[maxthread];
	contextqueue ready_queue[3];//0:high priority   1:normal priority  2:low priority
	thread_dt main_thread;
	contextqueue spare_queue;
	thread_dt *current;
public:
	static contextqueue& get_readyqueue(uint32 priority)

	static contextqueue& get_currentreadyqueue()

	static void reschedule();

	static inline void init()

	static inline thread_dt* getcurrentcontext()

	static inline void __yield()

	static inline void yield()

	static inline void __lowpriorityyield()

	static inline void lowpriorityyield()

	static inline void sleep(uint32 Millisecond = 250)

	static inline void threadexit()

	static inline void reset_threadpool()

	//create_thread should only be called in thread context. Not in interrupt/dpc context.
#ifdef PROBE_LOG
	static void create_thread(const char* funcname,thread_fn thread_start,void* parg, uint32 priority);
#else
	static void create_thread(thread_fn thread_start,void* parg, uint32 priority);
#endif

#ifdef WIN32
	static VOID CALLBACK run_thread(LPVOID pcontext);
#else
	static void run_thread();
#endif

#ifdef PROBE_LOG
	static inline void thread_printf(void);
#endif

};
```

`class thread_lib`提供了调度器工作所必要的成员变量和调度方法

### **调度器成员变量的简要说明**

变量名|功能说明
:--:|--
lasttick|调度器上一次读取的timer计数，代表某时刻系统累积的时间计数，类似Linux 的jiffies
maxthread|定义线程池能支持的最大线程数，这个限制通常取决于平台系统所定义的PID（Process Identify）字段的宽度，在本例取决于处理算力及下游处理能力的带宽极限
instance|所构造的thread lib静态单例，方便将线程池放置于系统规划的快速存储段以加速调度器的调度效能
extcontext|在单例中构造的`class threadext_dt`静态实例数组
availablecontext|在单例中构造的`class thread_dt`静态实例数组
ready_queue|调度器中已注册实际操作任务的线程池，分为high_priority, normal_priority, low_priority三个独立优先级的线程池
main_thread|调度器的主线程，即main函数产生的线程
spare_queue|在单例中构造的线程池，用于存放调度器未注册任务的所有可用空白线程元素 
current|调度器当前在执行的线程元素


### **调度器调度方法的简要说明**

---
操作函数|功能说明
:--:|--
get_readyqueue|获得指定优先级的线程池实例
get_currentreadyqueue|获得当前运行任务所在的优先级线程池实例
reschedule|调度器重调度方法，按照指定的调度策略将当前执行任务占用的处理器计算资源释放，并从ready_queue中选出下一个线程提交到处理器执行 
init|调度器的初始化方法
getcurrentcontext|获得当前正在执行的线程元素的实例
__yield|普通中断模式下的处理器计算资源替换方法，让当前执行的线程任务让出处理器资源，并交给新的线程任务
yield|快速中断模式下的处理器资源替换方法，作用与普通模式下类似
__lowpriorityyield|普通中断模式下的将当前任务让步到low priority线程池队列的方法
lowpriorityyield|快速中断模式下将当前任务让步到low priority线程池的方法
sleep|使当前休眠指定时间的间隔
threadexit|子线程退出执行并返回主线程的方法
reset_threadpool|调度器内部资源的初始化方法
create_thread|注册线程任务到空白线程元素
run_thread|执行线程任务的统一入口
thread_printf|调度器debug使用的打印函数
linkinterrupt|调度器线程任务与中断链接方法



### 调度器的初始化过程

调度器通过init和reset_threadpool两个函数完成内部资源节点的初始化操作，其中reset_threadpool是init函数调用的子程

`reset_threadpool`函数的源码如下：

```cpp
	static inline void reset_threadpool()
	{
#ifdef WIN32
		for (uint32 i=0; i!=maxthread; ++i)
		{
			LPVOID thread_fiber = instance.availablecontext[i].thread_fiber;
			if (thread_fiber != NULL)
			{
				DeleteFiber(thread_fiber);
			}
		}
#endif
		//memset(&instance,0,sizeof instance);
		memset(&instance,0,sizeof(instance));
		memset(extcontext,0,sizeof(extcontext));
		for(uint32 i = high_priority; i <= low_priority; ++i)
		{
			instance.ready_queue[i].init();
		}
		instance.spare_queue.init();
		for(uint32 i=0; i!=maxthread; ++i)
		{
			instance.availablecontext[i].extdat=&extcontext[i];
			instance.spare_queue.insert(&instance.availablecontext[i]);
		}
	}
```

**上述代码操作流程如下**

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-thread_poolreset-web.jpg)

调度器资源初始化操作将类中使用的静态资源的内存空间段做归0操作，并将线程实例（`class thread_dt`）与线程操作函数实例（`class threadext_dt`）建立一对一绑定产生可用的空白线程元素并加入到spare_queue供调度器随时拾取。采用静态数据资源构建调度器的内部线程资源目的在于提高调度器的工作性能，详细原因将在下文阐述。

`init`函数的源码如下：

```cpp
	static inline void init()
	{
		instance.reset_threadpool();

#ifdef WIN32
		instance.main_thread.thread_fiber = ConvertThreadToFiber(NULL);
		ASSERT(instance.main_thread.thread_fiber != NULL,LEVEL_NORMAL);
#endif

		instance.ready_queue[low_priority].insert(&(instance.main_thread));
		instance.current = &(instance.main_thread);
#ifdef PROBE_LOG
		instance.lasttick = reg_ops::gettickcount();
		instance.current->count = 0;
#endif
	instance.current->priority = low_priority;

	}
```

init函数的流程如下，在调用reset_threadpool初始化资源后，设置主线程和当前线程的状态

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-thread_poolreset-web.jpg)

### 调度器资源的获取
get_readyqueue， getcurrentcontext,, get_currentreadyqueue是调度器三个资源状态获取方法，分别用于获取指定条件下的线程资源

```cpp
static contextqueue& get_readyqueue(uint32 priority)
{
	return instance.ready_queue[priority];
}
static contextqueue& get_currentreadyqueue()
{
	return instance.ready_queue[instance.current->priority];
}
static inline thread_dt* getcurrentcontext()
{
	return instance.current;
}
static inline void __yield()
```

`get_readyqueue`用于获得指定优先级的线程池队列

`get_currentreadyqueue`用于获得当前正在执行线程所在优先级的线程池队列

`getcurrentcontext`用于获得当前正在执行线程的线程对象

### 调度器任务的注册方法

调度器通过`create_thread`函数将用户函数绑定到空白线程对象，并注册到ready_queue线程池中等待调度器提交到处理器执行

```cpp
void thread_lib::create_thread(thread_fn thread_start,void* parg, uint32 priority)
#endif
{
	ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
	ASSERT(priority <= low_priority, LEVEL_NORMAL);
	thread_dt *pcontext = instance.spare_queue.current();
	ASSERT(pcontext!=NULL,LEVEL_NORMAL);
	instance.spare_queue.remove();
	pcontext->next = NULL;
	pcontext->priority = priority;
	pcontext->extdat->thread_start = thread_start;
	pcontext->extdat->thread_arg = parg;
#ifndef WIN32
	memset(pcontext->extdat->astack,0,threadext_dt::thread_stack_size);
#endif // WIN32
#ifdef PROBE_LOG
	pcontext->count = 0;
	memset(pcontext->funcname,' ',sizeof(pcontext->funcname));
	const char* funcnamebody=funcname;
	const char* current=funcname;
	while(*current!='\0')
	{
		if(*current==':')
		{
			funcnamebody=current+1;
		}
		++current;
	}
	for(uint32 i=0;i!=sizeof(pcontext->funcname);++i)
	{
		char deschar=funcnamebody[i];
		if(deschar=='\0')
			break;
		pcontext->funcname[i]=deschar;
	}
#endif
#ifdef WIN32
	pcontext->thread_fiber  = CreateFiber(threadext_dt::thread_stack_size, &run_thread, NULL);
	ASSERT(pcontext->thread_fiber != NULL,LEVEL_NORMAL);
#else
	pcontext->sp = ((uint32)pcontext->extdat->astack)+threadext_dt::thread_stack_size-60;
	pcontext->r15 = (uint32)run_thread-8;
#endif
	uint32 status = clearinterruptacquire();
	instance.ready_queue[priority].insert(pcontext);
	interruptrestore(status);
}
```

流程如下

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-create_thread-web.jpg)

线程栈空间地址以高位地址作为栈底，逐渐向低位地址扩展栈空间范围，在以上代码中，实际的栈空间地址比定义最大栈空间地址小60个byte，目的使不同线程各自的栈空间之间留出足够的安全距离，防止某个线程由于stack overflow crash对其他线程栈区产生破坏性覆盖操作。

按照以上定义，处理通用寄存器文件GPR的第16个寄存器r15存放子过程的返回地址，由于调度器本身属于低级非抢占式调度器，每个线程任务在获得cpu计算资源后将不会被中断打断，一直执行至函数完毕，因此每个子过程的返回地址都被注册到`class thread_lib`的静态成员函数`run_thread`, 具体的原理将在以下调度器过程说明中详细阐述。实际子过程返回地址根据`pcontext->r15 = (uint32)run_thread-8`所示，位于`run_thread`函数label之前一个Dword地址, 这是由于Microblaze处理器的branch模块存在分支预测槽结构（**delay slot**）

**根据Xinlinx MicroBlaze Processor Reference Guide UG984 (v2018.3) Nov 14, 2018, 55页及58页关于分支延迟槽的描述如下**
>
>A control hazard occurs when a branch is taken, and the next instruction is not immediately available. This results in stalling the pipeline. MicroBlaze provides delay slot branches and the optional branch target cache to reduce the number of stall cycles.
>

>
>***Delay Slots***
>
>When executing a taken branch with delay slot, only the fetch pipeline stage in MicroBlaze is flushed. The instruction in the decode stage (branch delay slot) is allowed to complete. This technique effectively reduces the branch penalty from two clock cycles to one. Branch instructions with delay slots have a D appended to the instruction mnemonic. For example, the BNE instruction does not execute the subsequent instruction (does not have a delay slot), whereas BNED executes the next instruction before control is transferred to the branch location.
>
>A delay slot must not contain the following instructions: IMM, IMML, branch, or break. Interrupts and external hardware breaks are deferred until after the delay slot branch has been completed. Instructions that could cause recoverable exceptions (for example unaligned word or halfword load and store) are allowed in the delay slot.
>If an exception is caused in a delay slot the ESR[DS] bit is set, and the exception handler is responsible for returning the execution to the branch target (stored in the special purpose register BTR). If the ESR[DS] bit is set, register R17 is not valid (otherwise it contains the address following the instruction causing the exception).
>
**存在分支预测槽结构的处理器，在执行branch类指令时，由于取指单元（IFU， Instruction Fetch Unit）预取的指令缓存会清空，导致IFU需要重新预取新的有效指令，因此跳转指令的效果会延迟数个cycle才能生效，从而在流水线上产生若干个cycle的空泡（bubble），为了遮盖这些流水线空泡，处理器会提前执行跳转指令之后的数条指令，因此对应上文赋值给r15的返回地址将比实际的`run_thread`地址提前两个指令左右的执行宽度，用于配合分支延迟槽的提前执行特征**

### 调度器的操作方法
调度器的操作方法主要有如下几种

- **线程重调度方法`reschedule`**
- **线程让步方法`yield, __yield, lowpriorityyield, __lowpriorityyield`**
- **线程任务执行方法`run_thread`**
- **线程任务推出方法`threadexit`**
- **线程休眠方法`sleep`**


#### 线程重调度函数 ***reschedule*** 

函数实现的代码如下

```cpp
void thread_lib::reschedule()
{
	thread_dt *pnewctx;
#ifdef PROBE_LOG
	uint32 curtick=reg_ops::gettickcount();
	instance.current->count += curtick - instance.lasttick;
	do
	{
		communicator::overheat_delay();
		if(laterthan(reg_ops::gettickcount(),currenttick))
		{
			uint32 newtick=reg_ops::gettickcount();
			accidletime+=newtick-curtick;
			curtick=newtick;
			disp_diagnoisisinfo();
		}
	}
	while((pnewctx = instance.ready_queue[high_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[normal_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[low_priority].current())==NULL);
	{
		uint32 newtick=reg_ops::gettickcount();
		accidletime+=newtick-curtick;
		instance.lasttick = newtick;
	}
#else
	do
	{
		communicator::overheat_delay();
	}
	while((pnewctx = instance.ready_queue[high_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[normal_priority].current())==NULL &&
		(pnewctx = instance.ready_queue[low_priority].current())==NULL);
#endif
#ifdef WIN32
	instance.current = pnewctx;
	LPVOID next_fiber =instance.current->thread_fiber;
	ASSERT(next_fiber != NULL,LEVEL_NORMAL);
	SwitchToFiber(next_fiber);
#else
	thread_dt *poldctx = instance.current;
	instance.current = pnewctx;
	__Yield(poldctx,pnewctx);
#endif
}
```

重调度函数实现的功能非常简单, 即按照从高到低的优先级从ready_queue线程池中取出下一个即将执行的线程元素，并使其获得当前正在执行线程所让步出处理器计算资源, 图示流程如下。

![restpool](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-reshudule-web.jpg)

过温判断是一个阻塞式的函数调用过程,当通过CPU读取到系统中温度传感器（Temperature Sendor）读数高过预设的过温阈值时，CPU需要循环进入`nop`指令以等待系统温度降低到安全阈值以下,等待函数`overheat_delay`的代码如下

```cpp
static inline void overheat_delay()
	{
		//Wait for a certain period of time.
		//1/2 CPU computation power.
		uint32 isrflag=clearinterruptacquire();
		uint32 tick=reg_ops::gettickcount();
		uint32 interval = timeinterval(instance.last_ohdelay_tick, tick);
		interval=Min(interval,reg_ops::tick_size*max_ohdelay_interval);
		uint32 tickguard=tick+interval;
		while(beforethan(reg_ops::gettickcount(),tickguard));
		instance.last_ohdelay_tick=reg_ops::gettickcount();
		interruptrestore(isrflag);
	}
```

在执行等待过程中，需要将系统的中断响应使能关闭,防止意外中断的介入打断系统降温过程。在过程中，系统需要读入实时计数器（Timer/R， Real Timer Clock）的当前计数，与预设的降温等待间隔累加计算得到tickguard值，当系统polling到的tick计数小于tickguard时，全系统除CPU外，业务均处于pending状态。tick 的概念类似Linux 系统中所提出的jiffies概念，即系统开机后，一段时间内累计的总时间周期基数，该计数用于系统执行一些延迟等待任务。

整个重调度函数的核心部分是用于执行线程替换的内嵌ASM函数`__Yield`



`Yield`函数使用内嵌式汇编调用接口,其接口形式如下

`extern void __Yield(thread_dt* poldctx,thread_dt* pnewctx);`

内嵌式汇编程序的参数传递方式一般有三种，常用的有通过汇编占位符方式引入参数和通过处理器paramerter寄存器引入参数。

通过汇编占位符引入参数的内联汇编格式如下

```x86asm
__asm__　__volatile__("Instruction List" : Output : Input : Clobber/Modify);
```

- **Instruction List**

Instruction List 是汇编指令序列。它可以是空的，比如：__asm__ __volatile__(""); 或 __asm__ ("");都是完全合法的内联汇编表达式

- **__volatile__**

__volatile__是GCC 关键字volatile 的宏定义
`#define __volatile__ volatile` __volatile__或volatile 是可选的。如果用了它，则是向GCC 声明不允许对该内联汇编优化

- **Output**

Output 用来指定当前内联汇编语句的输出

- **Input**

Input 域的内容用来指定当前内联汇编语句的输入Output和Input中，格式为形如“constraint”(variable)的列表（逗号分隔)

- **Clobber/Modify**
  
有时候，你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改，希望GCC在编译时能够将这一点考虑进去。那么你就可以在Clobber/Modify域声明这些寄存器或内存。这种情况一般发生在一个寄存器出现在"Instruction List"，但却不是由Input/Output操作表达式所指定的，也不是在一些Input/Output操作表达式使用"r"约束时由GCC 为其选择的，同时此寄存器被"Instruction List"中的指令修改，而这个寄存器只是供当前内联汇编临时使用的情况。


- **通用约束**
约束 Input/Output 意义 g I,O 表示可以使用通用寄存器，内存，立即数等任何一种处理方式。 0,1,2,3,4,5,6,7,8,9 I 表示和第n个操作表达式使用相同的寄存器/内存

例如：
```x86asm
__asm__ ("popl %0 \n\t"
		 "movl %1, %%esi \n\t"
		 "movl %2, %%edi \n\t": 
		 "=a"(__out): 
		 "r" (__in1), 
		 "r" (__in2));
```
此例中，%0对应的就是Output操作表达式，它被指定的寄存器是%eax，整个Instruction List的第一条指令popl %0，编译后就成为popl %eax，这时%eax的内容已经被修改，随后在Instruction List后，GCC会通过movl %eax, address_of_out这条指令将%eax的内容放置到Output变量__out中。对于本例中的两个Input操作表达式而言，它们的寄存器约 束为"r"，即要求GCC为其指定合适的寄存器，然后在Instruction List之前将__in1和__in2的内容放入被选出的寄存器中，如果它们中的一个选择了已经被__out指定的寄存器%eax，假如是__in1，那 么GCC在Instruction List之前会插入指令movl address_of_in1, %eax，那么随后popl %eax指令就修改了%eax的值，此时%eax中存放的已经不是Input变量__in1的值了，那么随后的movl %1, %%esi指令，将不会按照我们的本意——即将__in1的值放入%esi中——而是将__out的值放入%esi中了。

而`__Yield`函数的实现采用的是通过处理器parameter寄存器传参的方式, 根据**Xinlinx MicroBlaze Processor Reference Guide UG984 (v2018.3) Nov 14, 2018** 195页描述, r5-r10是Mircoblaze处理器GPR中的参数寄存器，引入参数按照形参顺序依次放入寄存器位置

![registerparam](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-yield-register-web.jpg)

在本例中使用r5和r6两枚参数寄存器分别存放poldctx与pnewctx指针, 调用`swi` save 指令按照class/struct内存排布结构，依次向内存段存入当前GPR的保存内容到poldctx指定空间,同时使用`lwi` load 指令将新线程中的上下文内容换入到处理器的上下文空间环境内。对于`class thread_dt`的实例其内存中的排布结构如下所示：

![classstruct](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post_bg_class_struct_web.jpg)

以上结构为`class thread_dt`在实例在内存中的排布结构，由于线程池元素构造了类的实例对象数组，因此在内存构造中没有this指针的构造内存空间。 

`__Yield`函数的源码实现如下

```avrasm
	.section .text
	.globl	__Yield
	.align	4
    .ent	__Yield
        .type __Yield, @function
__Yield:
	//save registers
	swi	r15,r5,4
	swi	r17,r5,8
	swi	r19,r5,12
	swi	r20,r5,16
	swi	r21,r5,20
	swi	r22,r5,24
	swi	r23,r5,28
	swi	r24,r5,32
	swi	r25,r5,36
	swi	r26,r5,40
	swi	r27,r5,44
	swi	r28,r5,48
	swi	r29,r5,52
	swi	r30,r5,56
	swi	r31,r5,60
	//store R1 in *poldctx->sp
	swi	r1,r5,0
	//set R1 to *pnewctx->sp
	lwi	r1,r6,0
	//restore registers
	lwi	r15,r6,4
	lwi	r17,r6,8
	lwi	r19,r6,12
	lwi	r20,r6,16
	lwi	r21,r6,20
	lwi	r22,r6,24
	lwi	r23,r6,28
	lwi	r24,r6,32
	lwi	r25,r6,36
	lwi	r26,r6,40
	lwi	r27,r6,44
	lwi	r28,r6,48
	lwi	r29,r6,52
	lwi	r30,r6,56
	rtsd	r15,8
	lwi	r31,r6,60
	.end	__Yield
```

代码中 "`.section .text`" 表示该段代码位于程序的text段，即指令正文， "`.globl	__Yield`" 表示函数的label名 __Yield全局空间可见，以方便链接器按名字执行链接操作，”`.align	4`“ 表示生成的二进制代码按照4字节对齐排布，对应microblaze作为RISC 32处理的标准格式 ”`.ent	__Yield`“表示作为__Yield程序的正文起始，函数正文从此开始 ”`.type __Yield, @function`"用于指定代码的类型，`__Yield`部分代码属于函数子程。"`.end	__Yield`"表示整个函数的结尾。

`__Yield`函数首先调用`swi`指令将以r15开始的15个上下文GPR内容保存到poldxtx内存段以+4偏址至+60偏址的这部分空间,最后把栈空间指针从r1复制到poldxtx内存段+0偏址完成现有进程的上下文保存。

新线程任务的注入的过程与保存过程相反，调用`lwi`指令首先将pnewxtx内存段以+0偏址的栈空间地址复制到r1寄存器 然后将以r15开始的15个上下文GPR内容从pnewctx的+4至+60偏址复制到处理器对应GPR, 然后使用`rtsd`将PC指针重定向到r15返回地址+8的位置，按照上文所提，`r15=run_thread=8`,因此重定向的PC指针地址为`run_thread`函数的统一入口地址。可以看到`rtsd` 分支指令提前到 `lwi r31, r6,60`指令前执行，其原因在于上文所提到的分支预测槽的影响，由于rtsd指令需要至少延迟一个指令周期才能生效，为了有效利用延迟带来的空泡，故将`rtsd`指令提前一个周期执行，使延迟时间槽正好被下一条指令的执行时间所填满,在调度器频繁使用线程切换时，可以提高一定的指令执行的效率。

#### 线程让步函数  
调度器提供了`yield, __yield, lowpriorityyield, __lowpriorityyield`四种线程让步函数，其源码如下：

```cpp
	static inline void __yield()
	{
		instance.ready_queue[instance.current->priority].rotate();
		setinterrupt();
		reschedule();
		clearinterrupt();
	}
	static inline void yield()
	{
		uint32 status = clearinterruptacquire();
		instance.ready_queue[instance.current->priority].rotate();
		interruptrestore(status);
		reschedule();
	}
	static inline void __lowpriorityyield()
	{
		uint32 priority = instance.current->priority;
		instance.ready_queue[priority].remove();
		instance.ready_queue[low_priority].inserthead(instance.current);
		setinterrupt();
		reschedule();
		clearinterrupt();
		instance.ready_queue[low_priority].remove();
		instance.ready_queue[priority].inserthead(instance.current);
	}
	static inline void lowpriorityyield()
	{
		uint32 priority = instance.current->priority;
		uint32 status = clearinterruptacquire();
		instance.ready_queue[priority].remove();
		instance.ready_queue[low_priority].inserthead(instance.current);
		interruptrestore(status);
		reschedule();
		status = clearinterruptacquire();
		instance.ready_queue[low_priority].remove();
		instance.ready_queue[priority].inserthead(instance.current);
		interruptrestore(status);
	}
```

`__yield` 和`yield`函数区别在于`__yield`函数对应普通中断模式而`yield`对应快速中断模式，两类线程让步函数的流程十分相似。

![yield](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-yield-web.jpg)

`__lowpriorityyield` 和`priorityyield`函数区别与上面的情况类似分别针对将当前任务让步到低优先级线程池队列场景在普通中断和快速中断模式的应用

![lowyield](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-lowyield-web.jpg)

#### 线程任务运行与退出方法  

**线程退出方法`threadexit`的实现源码如下：**

```cpp
	static inline void threadexit()
	{
#ifdef PROBE_LOG
		instance.current->extdat->thread_start=NULL;
		instance.current->extdat->thread_arg=NULL;
#endif
		ASSERT((instance.current != NULL),LEVEL_NORMAL);
		uint32 status = clearinterruptacquire();

		instance.ready_queue[instance.current->priority].remove();

		interruptrestore(status);
		instance.spare_queue.insert(instance.current);
		instance.reschedule();
	}
```

调度器的线程退出方法即任一当前线程完成既定的线程函数后退出原线程上下文的方法,其流程如下图

![exit](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-threadexit-web.jpg)

**线程运行方法`threadexit`的实现源码如下：**

```cpp
void thread_lib::run_thread()
{
	instance.current->extdat->thread_start(instance.current->extdat->thread_arg);
	threadexit();
}
```

`run_thread`函数是调度器类的静态函数方法，是用户定义子线程运行最重要的统一调度入口,所有子线程获得处理器计算资源后初始的执行位置都将从`run_thread`开始和结束，其流程如下。

![run](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-run_thread-web.jpg)

在执行`run_thread`方法之前，一般已经通过`reschedule`方法将新线程任务设置为当前的current线程，因此在`run_thread`执行中，函数任务将始终执行current线程的函数任务方法。通过统一的线程任务进入的方式，使调度器在多线程上下文切换的过程中能够始终有效管理子线程的运行行为。

#### 线程任务休眠方法  

调度器的休眠方法将针对主线程执行以毫秒为单位的指定时间延迟，在延迟时间内，通过循环`yield`调用重调度程序，使其他子线程分别得以运行，线程最终返回主线程时,通过读取timer得到tick计数判断是否达到预定的时间延迟, 由于延迟判定需要切换回主线程才能执行，依次当线程池中的用户线程过多时，延迟等待的时间并不一定十分精确，会超出预设的等待时间。

![sleep](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-sleep-web.jpg)

#### 线程中断绑定方法  

调度器提供了中断绑定线程任务的接口，但在此种低层次抢占式调度器中并没有使用中断机制来增加调度任务的场景情况

**中断绑定接口的代码如下**

```cpp
static inline void linkinterrupt(uint32 ISRID,ISRCallBack f)
{
	aISRFunc[ISRID] = f;
}
```

microbalze的处理器采用low-latancy中断查询机制，触发中断后会进入统一中断服务接口函数，查询具体的中断事件源并处理中断,在**根据Xinlinx MicroBlaze Processor Reference Guide UG984 (v2018.3) Nov 14, 2018第85页到86页对中断机制有详细描述**

>**Interrupt**

>MicroBlaze supports one external interrupt source (connected to the Interrupt input port). The processor only reacts to interrupts if the Interrupt Enable (IE) bit in the Machine Status Register (MSR) is set to 1. On an interrupt, the instruction in the execution stage completes while the instruction in the decode stage is replaced by a branch to the interrupt vector. This is either address C_BASE_VECTORS + 0x10, or with low-latency interrupt mode, the address supplied by the Interrupt Controller.

>The interrupt return address (the PC associated with the instruction in the decode stage at the time of the interrupt) is automatically loaded into general purpose register R14. In addition, the processor also disables future interrupts by clearing the IE bit in the MSR. The IE bit is automatically set again when executing the RTID instruction.

>Interrupts are ignored by the processor if either of the break in progress (BIP) or exception in progress (EIP) bits in the MSR are set to 1.

>By using the parameter C_INTERRUPT_IS_EDGE, the external interrupt can either be set to level-sensitive or edge-triggered:

>• When using level-sensitive interrupts, the Interrupt input must remain set until
> MicroBlaze has taken the interrupt, and jumped to the interrupt vector. Software must
> cknowledge the interrupt at the source to clear it before returning from the interrupt
> handler. If not, the interrupt is taken again, as soon as interrupts are enabled when
>returning from the interrupt handler.

>• When using edge-triggered interrupts, MicroBlaze detects and latches the Interrupt
>input edge, which means that the input only needs to be asserted one clock cycle. The
>interrupt input can remain asserted, but must be deasserted at least one clock cycle
>before a new interrupt can be detected. The latching of an edge-triggered interrupt is
>independent of the IE bit in MSR. Should an interrupt occur while the IE bit is 0, it will
>immediately be serviced when the IE bit is set to 1.

>With periodic interrupt sources, such as the FIT Timer IP core, that do not have a method to clear the interrupt from software, it is recommended to use edge-triggered interrupts.

>**Low-latency Interrupt Mode**

>A low-latency interrupt mode is available, which allows the Interrupt Controller to directly supply the interrupt vector for each individual interrupt (using the Interrupt_Address input port). The address of each fast interrupt handler must be passed to the Interrupt Controller when initializing the interrupt system. When a particular interrupt occurs, this address is supplied by the Interrupt Controller, which allows MicroBlaze to directly jump to the handler code.

>With this mode, MicroBlaze also directly sends the appropriate interrupt acknowledge to the Interrupt Controller (using the Interrupt_Ack output port), although it is still the responsibility of the Interrupt Service Routine to acknowledge level sensitive interrupts at the source.

>This information allows the Interrupt Controller to acknowledge interrupts appropriately, both for level-sensitive and edge-triggered interrupt.

>To inform the Interrupt Controller of the interrupt handling events, Interrupt_Ack is set to:

>• 01: When MicroBlaze jumps to the interrupt handler code,

>• 10: When the RTID instruction is executed to return from interrupt,

>• 11: When MSR[IE] is changed from 0 to 1, which enables interrupts again.

>The Interrupt_Ack output port is active during one clock cycle, and is then reset to 00

程序的入口地址+0x10的偏移地址部分即统一的中断入口函数地址

```avrasm
	.globl _start
        .section .vectors.reset, "ax"
	.align 2
        .ent _start
        .type _start, @function
_start:
        brai    _start1
        .end _start

	.globl _interrupthandle
        .section .vectors.interrupt, "ax"
    .align 2
        .ent _interrupthandle
        .type _interrupthandle, @function
_interrupthandle:
        brai    PreemptiveInterrupt
        .end _interrupthandle
```
当触发中断后，处理器会自动跳转到`_interrupthandle`执行中断服务任务,并跳转至`PreemptiveInterrupt`开始执行中断查询任务，并执行相关的中断处理任务，`PreemptiveInterrupt`中断查询服务函数代码如下,因与调度器工作流程无关，此处不展开分析

```cpp
void PreemptiveInterrupt(void)
{
	uint32 CurrentDPCLevel = dpc_lib::instance.level;
	dpc_lib::instance.level = dpc_lib::interruptlevel;
	uint32 IntrStatus  =  reg_ops::get_interrupt_status();
	while (IntrStatus)
	{
		uint32 IntrMask = ((IntrStatus^(IntrStatus-1))+1)>>1;
		uint32 IntrIndex;
		IntrIndex = bitscanreverse(IntrMask);
		aISRFunc[IntrIndex]();
		reg_ops::ack_interrupt(IntrMask);
		IntrStatus  = reg_ops::get_interrupt_status();
	}

	dpc_lib::instance.level = CurrentDPCLevel;
	while (true)
	{
		uint32 scheduleMask = dpc_lib::instance.enablemask & dpc_lib::instance.triggermask;
		uint32 NewDPCLevel = bitscan(scheduleMask);
		if (NewDPCLevel+1 >= CurrentDPCLevel)
			break;

		//Save Current DPCLevel and Registers
		dpc_lib::instance.level = NewDPCLevel+1;
		dpc_lib::instance.triggermask ^= (0x80000000u >> NewDPCLevel);
		__asm__ __volatile__ ("addik r1, r1, -4":::"memory");
		__asm__ __volatile__ ("swi r14, r1, 0":::"memory");

		//Enable Interrupt
		setinterrupt();

		dpc_lib::instance.dpcfun[NewDPCLevel]();

		//Disable Interrupt
		clearinterrupt();

		//Restore Current DPCLevel and Registers
		__asm__ __volatile__ ("lwi r14, r1, 0":::"memory");
		__asm__ __volatile__ ("addik r1, r1, 4":::"memory");
		dpc_lib::instance.level = CurrentDPCLevel;
	}
}
```

- ## 调度器的工作流程

通过以上对调度器主要代码的分析我们开始开始对调度器的工作展开模拟过程分析

### 调度器资源存活的内存物理区间
为了实现调度器工作过程中更高的响应性能，需要优化调度器工作中资源开销过程中的IO访存性能, 本例中将调度器整体的实现采用静态实例资源实现，并通过链接手段排布在处理器所拥有的紧耦合内存（TCM， Tight Couppling Memory）上, MicroBlaze 拥有一块指令和数据统一使用的TCM内存，称为BRAM，处理器内核访问BRAM的延迟通常在5个时钟周期以内，小于访问主存DDR的数百个时钟周期延迟。
![bram](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-bram-web.jpg)

本例通过在链接脚本ld.script中自定义了用户使用的快速段FASTDATA_SECTION(fastdata),通过指定静态数据存放位置将调度器资源指定到BRAM空间内

调度器资源建立位置代码
```cpp
#define FASTDATA_SECTION    __attribute__ ((section ("fastdata")))

thread_lib thread_lib::instance FASTDATA_SECTION;
```
**ld.script**
```bash
_STACK_SIZE = DEFINED(_STACK_SIZE) ? _STACK_SIZE : 0x100000;
_HEAP_SIZE = DEFINED(_HEAP_SIZE) ? _HEAP_SIZE : 0;

/* Define Memories in the system */

MEMORY
{
   microblaze_0_i_bram_ctrl_microblaze_0_d_bram_ctrl : ORIGIN = 0x00000050, LENGTH = 0x0001FFB0
   axi_7series_ddrx_0_S_AXI_BASEADDR : ORIGIN = 0xC0000000, LENGTH = 0x3BF60000
}

/* Specify the default entry point to the program */

ENTRY(_start)

/* Define the sections, and where they are mapped in memory */

SECTIONS
{
.vectors.reset 0x00000000 : {
   *(.vectors.reset)
} 
.vectors.interrupt 0x00000010 : {
   *(.vectors.interrupt)
} 
.vectors.exception 0x00000020 : {
   *(.vectors.exception)
} 

.text : {
   *(.text)
   *(.text.*)
   *(.gnu.linkonce.t.*)
} > microblaze_0_i_bram_ctrl_microblaze_0_d_bram_ctrl

.fastdata : {
   . = ALIGN(4);
   *(.fastdata)   
} > microblaze_0_i_bram_ctrl_microblaze_0_d_bram_ctrl
}
```

### 调度器的模拟工作流程

以下通过流程图来展示整个调度器生命周期的工作工程

**以下通过流程图来展示整个调度器生命周期的工作过程**
1. 调度器完成初始化过程后如下图所示处理器GPR被主线程的上下文环境所占据，此时ready_queue中尚无有效线程单元，current指针指向main_thread实例空间（内容为空） 

![init](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-flow-init-web.jpg)

2. 用户通过`create_thread`方法不断从spare_queue中抽取空白线程单元填入各类线程任务方法，此时ready_queue中high/normal/low三种优先级队列中被注册了若干线程任务函数，current指针仍指向main_thread实例空间（内容为空）

![create](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-flow-create-web.jpg/)

3.  程序执行`yield`方法从ready_queue中按照从高到底优先级队从对应优先级列抽取线程任务对象，将其与current指针绑定，启动现场让步后，主线程上下文被报错到main_thread内存空间并被插入到low-priority队列的尾部，意味着主线程只有等待当前线程池中所有的线程任务执行完毕才能重新获得CPU的计算资源。 

![yield](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-flow-yield-web.jpg)

4.  `yield`方法会将除主线程以外所有线程执行的启动位置定位到调度的统一执行函数入口"`run_thread`", 当执行完current所指向的线程所承载的任务函数后， 将已执行完的线程从ready_queue中删除，放回到spare_queue队列，并再次启动`reschedule`过程从线程池挑选新的线程任务提交给处理器执行。

![exit](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-flow-exit-web.jpg)

5.  当线程池中所有用户程序任务被执行完毕并放回到spare_queue, 主线程将再次获得处理器计算资源，主线程将按照执行`yield`时的上下文继续向下执行`yield`之后的程序。

![return](https://github.com/zidanemarks/zidanemarks.github.io/raw/master/img/post-bg-flow-return-web.jpg)



- ## 与调度器相关的事件与信号量方法
原始设计中同样提供了与调度器运行相关的事件与信号量方法

### **线程事件方法**
```cpp
class event_dt
{
private:
	volatile uint32 status;
	thread_dt* volatile thread;
public:
	inline void init(uint32 initialvalue)
	{
		status = initialvalue;
		thread=NULL;
	}
	inline bool isset() const
	{
		return status!=0;
	}
	inline void __set()
	{
		ASSERT(!isinterruptenabled(),LEVEL_NORMAL);
		status = 1;
		if(thread != NULL)
		{
			thread_lib::get_readyqueue(thread->priority).insert(thread);
			thread=NULL;
		}
	}
	inline void set()
	{
		uint32 oldstatus = clearinterruptacquire();
		ASSERT(oldstatus,LEVEL_INFO);
		__set();
		interruptrestore(oldstatus);
	}
	inline void reset()
	{
		status = 0;
	}
	inline void __wait()
	{
		ASSERT(!isinterruptenabled(),LEVEL_NORMAL);
		ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
		if(status == 0)
		{
			thread_lib::get_currentreadyqueue().remove();
			ASSERT(thread==NULL,LEVEL_NORMAL);
			thread=thread_lib::getcurrentcontext();
			setinterrupt();
			thread_lib::reschedule();
			clearinterrupt();
		}
	}
	inline void wait()
	{
		ASSERT(isinterruptenabled(),LEVEL_NORMAL);
		ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
		uint32 oldstatus = clearinterruptacquire();
		if(status == 0)
		{
			thread_lib::get_currentreadyqueue().remove();
			ASSERT(thread==NULL,LEVEL_NORMAL);
			thread=thread_lib::getcurrentcontext();
			interruptrestore(oldstatus);
			thread_lib::reschedule();
		}
		else
		{
			interruptrestore(oldstatus);
		}
	}
};
```

本例实现的事件用于用户线程之间的触发等待通信，其成员变量和方法的含义如下

---
成员变量|功能说明
:--:|--
status|事件阻塞式等待标志，0为阻塞等待，非0则为非阻塞访问
thread| 用于承载阻塞等待线程的线程容器,待事件触发后返回

---
操作函数|功能说明
:--:|--
init| 事件初始化方法，用于设置事件实例的等待方式(默认为0)和承载线程（设为NULL）
isset|查看事件有无被触发（status设置为0）
__set|事件触发函数，设置status状态，并将事件等待所在线程重新注册线程池队列末尾
set|事件触发线程，用于开关中断并调用__set
reset|事件重置方法，将事件实例状态归为初始化状态
__wait|普通中断模式下的事件等待方法，为整个事件通信流程的发起函数
wait|快速中断模式下的事件等待方法，为整个事件通信流程的发起函数


### **线程信号量方法**
```cpp
class semaphore_dt
{
private:
	volatile int32 status;
	thread_dt* volatile thread;

public:
	inline semaphore_dt()
	{
	}
	inline semaphore_dt(int32 initialvalue)
	{
		init(initialvalue);
	}
	inline void init(int32 initialvalue)
	{
		status = initialvalue;
		thread=NULL;
	}
	inline void __inc()
	{
		ASSERT(!isinterruptenabled(),LEVEL_NORMAL);
		if(status == 0)
		{
			if(thread == NULL)
			{
				++status;
			}
			else
			{
				thread_lib::get_readyqueue(thread->priority).insert(thread);
				thread=NULL;
			}
		}
		else
		{
			++status;
		}
	}
	inline void inc()
	{
		uint32 oldstatus = clearinterruptacquire();
		ASSERT(oldstatus,LEVEL_INFO);
		__inc();
		interruptrestore(oldstatus);
	}
	inline int32 getresourcecount() const
	{
		return status;
	}
	inline bool isneedwait() const
	{
		return status <=0;
	}
	inline bool __trywait()
	{
		ASSERT(!isinterruptenabled(),LEVEL_NORMAL);
		ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
		if(status <= 0)
		{
			return false;
		}
		--status;
		return true;
	}
	inline bool trywait()
	{
		uint32 oldstatus = clearinterruptacquire();
		ASSERT(oldstatus,LEVEL_INFO);
		bool ret=__trywait();
		interruptrestore(oldstatus);
		return ret;
	}
	inline void __wait()
	{
		ASSERT(!isinterruptenabled(),LEVEL_NORMAL);
		ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
		if(status <= 0)
		{
			thread_lib::get_currentreadyqueue().remove();
			ASSERT(thread==NULL,LEVEL_NORMAL);
			thread=thread_lib::getcurrentcontext();

			setinterrupt();
			thread_lib::reschedule();
			clearinterrupt();
		}
		else
		{
			--status;
		}
	}
	inline void wait()
	{
		ASSERT(isinterruptenabled(),LEVEL_NORMAL);
		ASSERT(dpc_lib::getdpclevel() == dpc_lib::threadlevel, LEVEL_NORMAL);
		uint32 oldstatus = clearinterruptacquire();
		if(status <= 0)
		{
			thread_lib::get_currentreadyqueue().remove();
			ASSERT(thread==NULL,LEVEL_NORMAL);
			thread=thread_lib::getcurrentcontext();
			interruptrestore(oldstatus);
			thread_lib::reschedule();
		}
		else
		{
			--status;
			interruptrestore(oldstatus);
		}
	}
};
```

本例的信号量用于用户线程之间的旗帜信令握手，其成员变量和方法的含义如下

---
成员变量|功能说明
:--:|--
status|用于初始化旗语允许的最大信号量，可用于控制用户线程并发执行的数量
thread| 用于承载阻塞等待线程的线程容器,待事件触发后返回

---
操作函数|功能说明
:--:|--
init|初始化信号量的最大授权数量，可用于控制使用该信号量同步的线程执行个数
__inc|旗语信号量的放回操作方法，用于恢复信号量的授权数
inc|执行旗语信号量的放汇操作，开关中断响应，调用__inc
getresourcecount|获得当前可用的信号量个数
isneedwait|判断当前信号量是否已经全部授权出（新等待授权任务需要等待）
__trywait|普通中断模式下尝试等待信号量容器授权信令，若没有效授权，申请授权线程不形成阻塞
trywait|快速中断模式下尝试等待信号量容器授权信令，若没有效授权，申请授权线程不形成阻塞	
__wait|普通中断模式下尝试等待信号量容器授权信令，若没有效授权，申请授权线程将阻塞
wait|快速中断模式下尝试等待信号量容器授权信令，若没有效授权，申请授权线程将阻塞

- ## 后记





















